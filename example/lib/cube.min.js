//cube.min.js
/*!
 * cube: example/cube.js
 * Authors  : fish (https://github.com/fishbar)
 * Create   : 2014-04-18 15:32:20
 * CopyRight 2014 (c) Fish And Other Contributors
 *
 * run in browser
 */
(function (HOST, rename) {

  var BASE = '';
  var CHARSET = 'utf-8';
  var VERSION = new Date().getTime();
  var TIMEOUT = 10000; // default 10's
  var DEBUG = false;
  var ENABLE_CSS = false;
  var ENABLE_SOURCE = window.localStorage ? window.localStorage.getItem('__cube_debug__') : false;

  function dummy() {}
  /**
   * Class Cube
   *
   * 1. used as loaded module enter
   *   Cube(name, requires, callback);
   * 2. used as Cube constructor
   *   var loader = new Cube(name);
   *   loader.load(requires, callback);
   * @public
   * @param
   */
  function Cube (name, requires, callback) {
    if (arguments.length === 3) {
      var ld = new Cube(name);
      ld.load(requires, callback);
    } else {
      this.name = name ? name : '_';
      this.base = BASE;
      this.charset = CHARSET;
    }
  }
  /** version **/
  Cube.toString = function () {return 'Cube:v$$version$$';};
  /**
   * init global setting for Cube
   * @static
   * @param  {Object} config {base, charset, version, debug, timeout}
   * @return {Object} Cube
   */
  Cube.init = function (config) {
    if (config.base && config.base !== '/') {
      BASE = config.base.replace(/\/$/, '');
    }
    if (config.charset) {
      CHARSET = config.charset;
    }
    if (config.version) {
      VERSION = config.version;
    }
    if (config.debug) {
      DEBUG = config.debug;
    }
    if (config.timeout) {
      TIMEOUT = config.timeout;
    }
    if (config.enableCss) {
      ENABLE_CSS = config.enableCss;
    }
    return this;
  };
  /**
   * global switch for loading compressed-code, or source code
   * it's useful in pre env for debug, much better then sourcemap
   * @public
   */
  Cube.debug = function () {
    if (window.localStorage) {
      var item = localStorage.getItem('__cube_debug__');
      if (item) {
        localStorage.removeItem('__cube_debug__');
      } else {
        localStorage.setItem('__cube_debug__', true);
      }
    }
  };
  /**
   * loading module async, this function only support abs path
   * @public
   * @param  {Path}     mod module abs path
   * @param  {Function} cb  callback function, usually with module.exports as it's first param
   * @return {Object}   Cube
   */
  Cube.use = function (mod, cb) {
    if (!mod) {
      throw new Error('Cube.use(moduleName) moduleName is undefined!');
    }
    if (!cb) {
      cb = dummy;
    }
    /** fix #12 **/
    if (mod.indexOf('./') === 0) {  // be compatible with ./test.js
      mod = mod.substr(1);
    } else if (mod[0] !== '/') {    // be campatible with test.js
      mod = '/' + mod;
    }

    var ll = new Cube();
    ll.load(mod, function (module, exports, require) {
      cb(require(mod));
    });
    return this;
  };
  /**
   * @interface inject css into page
   * css inject is comp
   * ie8 and lower only support 32 stylesheets, so this function
   * @param  {String} name module name
   * @param  {CssCode} css  css code
   */
  Cube.css = function (mod, namespace) {};
  /**
   * remove module from mem cache
   * css remove should override this function to delete style node
   * @interface
   * @param  {Path}     name module name
   * @return {Object}   Cube
   */
  Cube.remove = function (name) {
    //
  };
  /**
   * register module in to cache
   * @param  {string} name    [description]
   * @param  {} exports [description]
   * @return {[type]}         [description]
   */
  Cube.register = function (name, exports) {
    var cached = this._cached[name];
    if (cached) {
      console.error('module already registered:', name);
    } else {
      this._cached[name] = exports;
    }
  };
  /**
   * module already loaded
   */
  Cube._cached = {};
  /**
   * module loaded broadcast
   */
  Cube._flag = {};
  Cube._tree = {};
  /**
   * global require function
   * @param  {[type]} mod [description]
   * @return {[type]}     [description]
   */
  function Require(mod, ns) {
    if (ns !== undefined) {
      var css = Cube._cached[mod];
      Cube.css(css, ns, mod);
    }
    return Cube._cached[mod];
  }
  /**
   * async loading resource
   * i.e
   *   async(modName, function(mod){ //TODO// });
   *   async(cssMod, nameSpace, function(){ //TODO// });
   * @param {Path}   mod   [description]
   * @param {Function|String} cb    [description]
   * @param {Function}   param
   */
  function Async(mod, param1, param2) {
    if (typeof param1 !== 'function') {
      if (!ENABLE_CSS) {
        console.warn('[Cube] dynamic loading css disabled!');
        return;
      }
      // mod cb -> namespace
      Cube.use(mod, function (css) {
        Cube.css(css, param1, mod);
        param2 && param2(css);
      });
    } else {
      Cube.use(mod, param1);
    }
  }
  /**
   get module by name
   **/
  Cube.module = function (name) {
    return this._cached[name];
  };
  Cube.prototype = {
    /**
     * load script from server
     * @param {string|array} require
     * @param {function} cb callback
     */
    load: function (req, cb) {
      var mName = this.name;
      var require = req;
      if (typeof require === 'string') {
        // setup file timeout
        setTimeout(function () {
          if (Cube._flag[req]) {
            console.error('load script timeout:', req);
          }
        }, TIMEOUT);
      }

      if (!require) {
        require = [];
      } else if (typeof require === 'string') {
        require = [require];
      }
      //if(!cb) cb = function(){};
      var len = require.length;
      var _stack = [];
      var ifCycle = false;
      this._load_stack = {
        req: _stack,
        total: len,
        cb: cb,
        count: 0
      };
      if (len) {
        for (var i = 0, tmp; i < len ; i++) {
          tmp = require[i];
          if (DEBUG) {
            if (!Cube._tree[tmp]) {
              Cube._tree[tmp] = {};
            }
            Cube._tree[tmp][mName] = true;
            ifCycle = this._checkCycle(tmp);
          }
          if (!ifCycle) {
            _stack.push(tmp);
            this._loadScript(tmp);
          }
        }
        if (!_stack.length) {
          this._leafMod(cb);
        }
      } else {
        this._leafMod(cb);
      }
    },
    /**
     * [_loaded description]
     * @return {[type]} [description]
     */
    _leafMod: function (cb) {
      var mod;
      var module = {exports : {}};
      if (cb) {
        mod = cb.apply(HOST, [module, module.exports, Require, Async, '', '']);
      }
      if (!mod) {
        mod = true;
      } else {
        mod.__filename = this.name;
      }
      Cube._cached[this.name] = mod;
      fireMod(this.name);
    },
    _checkCycle: function (name, parents) {
      if (!parents) {
        parents = [name];
      }
      var tmp = Cube._tree[name];
      var tmpParent;
      var flag;
      if (!tmp) {
        return false;
      }
      for (var i in tmp) {
        if (parents.indexOf(i) !== -1) {
          parents.unshift(i);
          console.warn('[WARNNING]', 'cycle require : ' + parents.join(' > '));
          return true;
        }
        tmpParent = parents.slice(0);
        tmpParent.unshift(i);
        flag = this._checkCycle(i, tmpParent);
        if (flag) {
          return true;
        }
      }
      return false;
    },
    _loadScript: function (name, bool) {
      var mod = Cube._cached[name];
      var self = this;
      var ww = Cube._flag;
      function cb(mm) {
        var flag = self._load_stack;
        var ok = false;
        if (Cube._cached[mm]) {
          flag.count ++;
          ok = self.name;
        }
        // check if all require is done;
        if (flag.total <= flag.count) {
          var module = {exports : {}};
          var s_filename = self.name;
          var s_dirname = s_filename.replace(/[^\/]*$/, '');
          var mod;
          if (flag.cb) {
            mod = flag.cb.apply(HOST, [module, module.exports, Require, Async, s_filename, s_dirname]);
          }
          if (!mod) {
            mod = true;
          } else {
            mod.__filename = self.name;
          }
          Cube._cached[self.name] = mod;
        }
        return ok;
      }

      if (mod) {
        ww = cb(name);
        if (ww !== false) {
          fireMod(ww);
        }
        return;
      } else if (mod === false) {
        ww[name].push(cb);
        return;
      }

      if (!ww[name]) {
        ww[name] = [];
      }
      ww[name].push(cb);
      Cube._cached[name] = false;
      var script = document.getElementsByTagName('head')[0].appendChild(document.createElement('script'));
      script.type = 'text/javascript';
      script.async = 'true';
      script.charset = this.charset;
      // because here can not detect css file or js file
      // so ignore js source file like:  jquery.scroll.js
      if (ENABLE_SOURCE && !/\.\w+\.js$/.test(name)) {
        name = name.replace(/\.js$/, '.source.js');
      }
      var _src = [ this.base, name, '?m=1&', VERSION];
      script.src = _src.join('');
    }
  };
  /**
   * fire a module loaded event
   * @param  {String} name modulename
   */
  function fireMod(name) {
    var wts = Cube._flag, ww, flag, res = {};
    ww = wts[name];
    if (ww) {
      for (var n = ww.length - 1; n >= 0; n --) {
        flag = ww[n](name);
        if (flag !== false) { // module relative ok
          ww.splice(n, 1);
          n = ww.length;
          if (flag) {
            res[flag] = true;
          }
        }
      }
      if (!ww.length) {
        delete  wts[name];
      }
      for (n in res) {
        // one module self is loaded ,so fire it
        fireMod(n);
      }
    }
  }

  rename = rename ? rename : 'Cube';
  if (HOST[rename]) {
    console.log('window.' + rename + ' already in using, replace the last "null" param in cube.js');
  } else {
    HOST[rename] = Cube;
  }
})(window, null);
//jade_runtime
Cube.register("jade_runtime",function(){var r={};function e(r,t){if(arguments.length===1){var a=r[0];for(var i=1;i<r.length;i++){a=e(a,r[i])}return a}var s=r["class"];var f=t["class"];if(s||f){s=s||[];f=f||[];if(!Array.isArray(s))s=[s];if(!Array.isArray(f))f=[f];r["class"]=s.concat(f).filter(n)}for(var l in t){if(l!="class"){r[l]=t[l]}}return r}r.merge=e;function n(r){return r!=null&&r!==""}r.joinClasses=t;function t(r){return Array.isArray(r)?r.map(t).filter(n).join(" "):r}function a(e,n){var a=[];for(var i=0;i<e.length;i++){if(n&&n[i]){a.push(r.escape(t([e[i]])))}else{a.push(t(e[i]))}}var s=t(a);if(s.length){return' class="'+s+'"'}else{return""}}r.cls=a;function i(e,n,t,a){if("boolean"==typeof n||null==n){if(n){return" "+(a?e:e+'="'+e+'"')}else{return""}}else if(0==e.indexOf("data")&&"string"!=typeof n){return" "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"}else if(t){return" "+e+'="'+r.escape(n)+'"'}else{return" "+e+'="'+n+'"'}}r.attr=i;function s(e,n){var a=[];var i=Object.keys(e);if(i.length){for(var s=0;s<i.length;++s){var f=i[s],l=e[f];if("class"==f){if(l=t(l)){a.push(" "+f+'="'+l+'"')}}else{a.push(r.attr(f,l,false,n))}}}return a.join("")}r.attrs=s;function f(r){var e=String(r).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");if(e===""+r)return r;else return e}r.escape=f;function l(r,e,n,t){if(!(r instanceof Error))throw r;if((typeof window!="undefined"||!e)&&!t){r.message+=" on line "+n;throw r}try{t=t||_dereq_("fs").readFileSync(e,"utf8")}catch(a){l(r,null,n)}var i=3,s=t.split("\n"),f=Math.max(n-i,0),u=Math.min(s.length,n+i);var i=s.slice(f,u).map(function(r,e){var t=e+f+1;return(t==n?"  > ":"    ")+t+"| "+r}).join("\n");r.path=e;r.message=(e||"Jade")+":"+n+"\n"+i+"\n\n"+r.message;throw r}r.rethrow=l;return r}());
//ejs_runtime
Cube.register("ejs_runtime",function(){var r={};r.first=function(r){return r[0]};r.last=function(r){return r[r.length-1]};r.capitalize=function(r){r=String(r);return r[0].toUpperCase()+r.substr(1,r.length)};r.downcase=function(r){return String(r).toLowerCase()};r.upcase=function(r){return String(r).toUpperCase()};r.sort=function(r){return Object.create(r).sort()};r.sort_by=function(r,n){return Object.create(r).sort(function(r,t){r=r[n],t=t[n];if(r>t)return 1;if(r<t)return-1;return 0})};r.size=r.length=function(r){return r.length};r.plus=function(r,n){return Number(r)+Number(n)};r.minus=function(r,n){return Number(r)-Number(n)};r.times=function(r,n){return Number(r)*Number(n)};r.divided_by=function(r,n){return Number(r)/Number(n)};r.join=function(r,n){return r.join(n||", ")};r.truncate=function(r,n,t){r=String(r);if(r.length>n){r=r.slice(0,n);if(t)r+=t}return r};r.truncate_words=function(r,n){var r=String(r),t=r.split(/ +/);return t.slice(0,n).join(" ")};r.replace=function(r,n,t){return String(r).replace(n,t||"")};r.prepend=function(r,n){return Array.isArray(r)?[n].concat(r):n+r};r.append=function(r,n){return Array.isArray(r)?r.concat(n):r+n};r.map=function(r,n){return r.map(function(r){return r[n]})};r.reverse=function(r){return Array.isArray(r)?r.reverse():String(r).split("").reverse().join("")};r.get=function(r,n){return r[n]};r.json=function(r){return JSON.stringify(r)};return r}());
//cube_css.min.js
!(function () {

if (typeof Cube === 'undefined') {
  return;
}

var parseCssRe = /\}\n?([\s\S]*?)\{/g;
Cube.css = function (css, namespace, file) {
  if (!css) {
    return;
  }
  if (namespace) {
    css = '}' + css;
    css = css.replace(parseCssRe, function (match, p1, offset, string) {
      var selectors = p1.split(',').map(function (selector) {
        return namespace + ' ' + selector.trim();
      });
      selectors = selectors.join(',');

      return '}\n' + selectors + '{';
    });
    css = css.slice(1);
  }

  var headNode = document.getElementsByTagName('HEAD')[0];
  var style = document.createElement('style');
  style.setAttribute('type', 'text/css');
  style.setAttribute('mod', file);
  headNode.appendChild(style);
  style.innerHTML = css;
};

})();